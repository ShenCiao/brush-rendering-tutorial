"use strict";(self.webpackChunkbrush_stroke_tutorial=self.webpackChunkbrush_stroke_tutorial||[]).push([[364],{9507:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>b,contentTitle:()=>w,default:()=>P,frontMatter:()=>k,metadata:()=>y,toc:()=>x});var r=n(7462),a=n(7294),o=n(3905),i=n(9477),s=n(5452),l=n(4866),c=n(5162),u=n(3764);const d={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"[",close:"]"},{open:"{",close:"}"},{open:"(",close:")"},{open:"'",close:"'",notIn:["string","comment"]},{open:'"',close:'"',notIn:["string"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},p={tokenPostfix:".glsl",defaultToken:"invalid",keywords:["const","uniform","break","continue","do","for","while","if","else","switch","case","in","out","inout","true","false","invariant","discard","return","sampler2D","samplerCube","sampler3D","struct","radians","degrees","sin","cos","tan","asin","acos","atan","pow","sinh","cosh","tanh","asinh","acosh","atanh","exp","log","exp2","log2","sqrt","inversesqrt","abs","sign","floor","ceil","round","roundEven","trunc","fract","mod","modf","min","max","clamp","mix","step","smoothstep","length","distance","dot","cross ","determinant","inverse","normalize","faceforward","reflect","refract","matrixCompMult","outerProduct","transpose","lessThan ","lessThanEqual","greaterThan","greaterThanEqual","equal","notEqual","any","all","not","packUnorm2x16","unpackUnorm2x16","packSnorm2x16","unpackSnorm2x16","packHalf2x16","unpackHalf2x16","dFdx","dFdy","fwidth","textureSize","texture","textureProj","textureLod","textureGrad","texelFetch","texelFetchOffset","textureProjLod","textureLodOffset","textureGradOffset","textureProjLodOffset","textureProjGrad","intBitsToFloat","uintBitsToFloat","floatBitsToInt","floatBitsToUint","isnan","isinf","vec2","vec3","vec4","ivec2","ivec3","ivec4","uvec2","uvec3","uvec4","bvec2","bvec3","bvec4","mat2","mat3","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","mat4","float","int","uint","void","bool"],operators:["=",">","<","!","~","?",":","==","<=",">=","!=","&&","||","++","--","+","-","*","/","&","|","^","%","<<",">>",">>>","+=","-=","*=","/=","&=","|=","^=","%=","<<=",">>=",">>>="],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,integersuffix:/([uU](ll|LL|l|L)|(ll|LL|l|L)?[uU]?)/,floatsuffix:/[fFlL]?/,encoding:/u|u8|U|L/,tokenizer:{root:[[/[a-zA-Z_]\w*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}],[/^\s*#\s*\w+/,"keyword.directive"],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":""}}],[/\d*\d+[eE]([\-+]?\d+)?(@floatsuffix)/,"number.float"],[/\d*\.\d+([eE][\-+]?\d+)?(@floatsuffix)/,"number.float"],[/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/,"number.hex"],[/0[0-7']*[0-7](@integersuffix)/,"number.octal"],[/0[bB][0-1']*[0-1](@integersuffix)/,"number.binary"],[/\d[\d']*\d(@integersuffix)/,"number"],[/\d(@integersuffix)/,"number"],[/[;,.]/,"delimiter"]],comment:[[/[^\/*]+/,"comment"],[/\/\*/,"comment","@push"],["\\*/","comment","@pop"],[/[\/*]/,"comment"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,{token:"string.quote",bracket:"@close",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,"white"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]]}};function h(e){return a.createElement(u.ML,(0,r.Z)({},e,{defaultLanguage:"glsl",onMount:(t,n)=>{n.languages.register({id:"glsl"}),n.languages.setMonarchTokensProvider("glsl",p),n.languages.setLanguageConfiguration("glsl",d),"function"==typeof e.onMount&&e.onMount(t,n)}}))}const m="const n = 32;\nconst maxRadius = 1/3;\n\nconst position = [];\nconst radius = [];\n\nconst gr = (1 + Math.sqrt(5)) / 2; // golden ratio\nconst pi = Math.PI;\n\nfor(let i = 0; i <= n; ++i){\n  let a = i / n;\n  let x =  -pi + (2 * pi * a);\n  let y = 1.0 / gr * Math.sin(x);\n  let r = Math.cos(x / 2.0) * maxRadius;\n\n  position.push(x, y);\n  radius.push(r);\n}\n\nreturn [position, radius];\n",f="precision mediump float;\nprecision mediump int;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec2 position0;\nin float radius0;\n//in float summedLength0;\nin vec2 position1;\nin float radius1;\n//in float summedLength1;\n\nout vec2 p; // position of the current pixel\nflat out vec2 p0;\nflat out float r0;\n//flat out float l0;\nflat out vec2 p1;\nflat out float r1;\n//flat out float l1;\n\nvoid main()\t{\n    r0 = radius0;\n    r1 = radius1;\n    p0 = position0;\n    p1 = position1;\n//    l0 = summedLength0;\n//    l1 = summedLength1;\n\n    vec2 tangentDirection = normalize(position1 - position0);\n    vec2 normalDirection = vec2(-tangentDirection.y, tangentDirection.x);\n    float cosTheta = (r0 - r1)/distance(p0, p1); // theta is the angle stroke tilt, there is a diagram in README to explain this.\n    // the vertex1 with radius is fully inside the vertex0.\n    if(abs(cosTheta) >= 1.0) return;\n\n    // Each instance is a trapzoid, whose vertices' positions are determined here.\n    // Use gl_VertexID {0, 1, 2, 3} to index and get the desired parameters.\n    // Be careful with the backface culling! We are ignoring it here.\n    vec2[] offsetSigns = vec2[](\n        vec2(-1.0,-1.0),\n        vec2(-1.0, 1.0),\n        vec2( 1.0, 1.0),\n        vec2( 1.0,-1.0)\n    );\n    vec2 offsetSign = offsetSigns[gl_VertexID];\n\n    vec2[] polylineVertexPositions = vec2[](position0, position0, position1, position1);\n    vec2 pos = polylineVertexPositions[gl_VertexID];\n\n    float radius = vec4(radius0, radius0, radius1, radius1)[gl_VertexID];\n\n    float tanHalfTheta = sqrt((1.0+cosTheta) / (1.0-cosTheta));\n    float cotHalfTheta = 1.0 / tanHalfTheta;\n    float normalTanValue = vec4(tanHalfTheta, tanHalfTheta, cotHalfTheta, cotHalfTheta)[gl_VertexID];\n    if(normalTanValue > 10.0 || normalTanValue < 0.1) return;\n\n    vec2 trapzoidVertexPosition = pos +\n        offsetSign.x * radius * tangentDirection +\n        offsetSign.y * radius * normalDirection * normalTanValue;\n    p = trapzoidVertexPosition;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(trapzoidVertexPosition, 0.0, 1.0);\n}\n",g="precision mediump float;\nprecision mediump int;\n\nin vec2 p;\nflat in vec2 p0;\nflat in float r0;\nflat in float l0;\nflat in vec2 p1;\nflat in float r1;\nflat in float l1;\n\nout vec4 outColor;\n\nvoid main() {\n    vec2 tangent = normalize(p1 - p0);\n    vec2 normal = vec2(-tangent.y, tangent.x);\n\n    // The local coordinate orgin at p0, x axis along the tangent direction.\n    float len = distance(p1, p0);\n    vec2 pLocal = vec2(dot(p-p0, tangent), dot(p-p0, normal));\n    vec2 p0Local = vec2(0, 0);\n    vec2 p1Local = vec2(len, 0);\n\n    float cosTheta = (r0 - r1)/len;\n    float d0 = distance(p, p0);\n    float d0cos = pLocal.x / d0;\n    float d1 = distance(p, p1);\n    float d1cos = (pLocal.x - len) / d1;\n\n    // Remove corners\n    if(d0cos < cosTheta && d0 > r0) discard;\n    if(d1cos > cosTheta && d1 > r1) discard;\n\n    outColor = vec4(0.0, 0.0, 0.0, 0.5);\n}\n";function v(){const e=(0,a.useRef)(),t=((0,a.useRef)(),(0,a.useRef)()),n=(0,a.useRef)();(0,a.useEffect)((()=>{const r=(1+Math.sqrt(5))/2,a=(Math.PI,e.current.clientWidth),o=a*(.5/r),l=4*r,c=l*(.5/r),u=new i.iKG(l/-2,l/2,c/2,c/-2,-1e3,1e3);u.position.z=5;const d=new i.CP7({antialias:!0,alpha:!0,premultipliedAlpha:!1});d.setSize(a,o),window.addEventListener("resize",(()=>{const t=e.current.clientWidth,n=t*(.5/r);d.setSize(t,n)})),e.current.appendChild(d.domElement);const p=new i.xsS,h=new s.o(u,d.domElement);h.enableRotate=!1,h.enableDamping=!1,h.screenSpacePanning=!0,h.addEventListener("change",(()=>{d.render(p,u)}));const v=new i.u9r;v.setIndex([0,1,2,2,3,0]);const k=new Function(m),[w,y]=k(),b=[...w],x=[...w.slice(2)],T=[...y],I=[...y.slice(1)];v.setAttribute("position0",new i.lb7(new Float32Array(b),2)),v.setAttribute("radius0",new i.lb7(new Float32Array(T),1)),v.setAttribute("position1",new i.lb7(new Float32Array(x),2)),v.setAttribute("radius1",new i.lb7(new Float32Array(I),1));const P=new i.FIo({vertexShader:f,fragmentShader:g,side:i.ehD,transparent:!0,glslVersion:i.LSk});return n.current=new i.SPe(v,P,I.length),n.current.frustumCulled=!1,p.add(n.current),t.current=()=>h.dispatchEvent({type:"change"}),t.current(),()=>{d.dispose()}}),[]);const r=(0,a.useCallback)(((e,t)=>{console.log(e)}),[]);return a.createElement(a.Fragment,null,a.createElement(l.Z,null,a.createElement(c.Z,{value:"geometry"},a.createElement(u.ZP,{height:"30vh",defaultLanguage:"javascript",defaultValue:m,onChange:r})),a.createElement(c.Z,{value:"vertex"},a.createElement(h,{height:"30vh",defaultValue:"uniform int x;"}))),a.createElement("div",{ref:e,style:{width:"100%"},onMouseDown:e=>e.preventDefault()}))}const k={title:"Introduction",sidebar_position:2},w=void 0,y={unversionedId:"Introduction/Introduction",id:"Introduction/Introduction",title:"Introduction",description:"This tutorial series will teach you how to use the modern GPU graphics pipeline to render brush strokes on vector curves.",source:"@site/docs/Introduction/Introduction.mdx",sourceDirName:"Introduction",slug:"/Introduction/",permalink:"/brush-stroke-tutorial/Introduction/",draft:!1,editUrl:"https://github.com/ShenCiao/brush-stroke-tutorial/tree/main/docs/Introduction/Introduction.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Introduction",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Table of Contents",permalink:"/brush-stroke-tutorial/"},next:{title:"Basics",permalink:"/brush-stroke-tutorial/category/basics"}},b={},x=[{value:"Modern GPU",id:"modern-gpu",level:2},{value:"Brush strokes",id:"brush-strokes",level:2},{value:"Vector curves",id:"vector-curves",level:2},{value:"Structure",id:"structure",level:2},{value:"Cite",id:"cite",level:2}],T={toc:x},I="wrapper";function P(e){let{components:t,...a}=e;return(0,o.kt)(I,(0,r.Z)({},T,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This tutorial series will teach you how to use the ",(0,o.kt)("strong",{parentName:"p"},"modern GPU")," graphics pipeline to render ",(0,o.kt)("strong",{parentName:"p"},"brush strokes")," on ",(0,o.kt)("strong",{parentName:"p"},"vector curves"),".\nThe contents mainly come from my research work ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ShenCiao/Ciallo"},"Ciallo: The next generation vector paint program"),".\nI will introduce this tutorial from the three aspects above."),(0,o.kt)("h2",{id:"modern-gpu"},"Modern GPU"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"sketchpad",src:n(8138).Z,width:"480",height:"360"})),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Draw lines in Ivan Sutherland's Sketchpad.")),(0,o.kt)("p",null,"Drawing lines or rendering strokes is one of the oldest topics in Computer Graphics.\nYou can easily find a lot of pioneering works, for example, ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm"},"Bresenham's line algorithm"),".\nThey emerged from an era with certain conditions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Programs ran without the benefit of parallelization."),(0,o.kt)("li",{parentName:"ul"},"Programs could access framebuffer directly without significant performance penalty.")),(0,o.kt)("p",null,"But time has changed, now we have modern GPU hardware crafted for graphics and parallel computing,\nand directly accessing a GPU framebuffer from a CPU can significantly hurt the performance.\nSo old algorithms may not satisfy your needs for real-time rendering."),(0,o.kt)("p",null,"In this tutorial, you will learn about the stroke rendering algorithms designed for the GPU graphics pipeline.\nWe (I and my mentor ",(0,o.kt)("a",{parentName:"p",href:"https://www.liyiwei.org/"},"Liyi-Wei"),") name these algorithms as ",(0,o.kt)("em",{parentName:"p"},"Articulated")," in our paper (mainly because they look like drawing an articulated arm).\nI assume our readers are already familiar with a graphics API like OpenGL or D3D.\nThis tutorial will concentrate more on the high-level algorithms than the implementation details."),(0,o.kt)("p",null,"Although graphics APIs provide us line primitives, including ",(0,o.kt)("inlineCode",{parentName:"p"},"LINES"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"LINE_STRIP"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"LINE_LOOP"),",\nthere are several well-known issues when using these primitives directly.\nCheck out Matt Deslauries' article ",(0,o.kt)("a",{parentName:"p",href:"https://mattdesl.svbtle.com/drawing-lines-is-hard#line-primitives_1"},"Drawing Lines is Hard")," if you know nothing about them.\nAs for us, the most significant issue is the limitation on the maximum line width or stroke radius.\nWe must be able to fully control the radius values when rendering brush strokes."),(0,o.kt)("h2",{id:"brush-strokes"},"Brush strokes"),(0,o.kt)("p",null,"Brush strokes refer to strokes drawn with the paint tool in graphics software such as Photoshop or Krita.\nArtists configure their digital brushes to control stroke properties like radius or stylization,\nthen stroke on the canvas with dedicated input devices: Tablet and Stylus.\nIf you're unfamiliar with tablets and styluses, you can watch the video below for more information:"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?app=desktop&v=83BRMfjJXIk"},(0,o.kt)("img",{parentName:"a",src:"https://img.youtube.com/vi/83BRMfjJXIk/maxresdefault.jpg",alt:"Tablet"}))),(0,o.kt)("p",null,"While you may recognize a brush stroke by its stylization, another crucial property could be ignored: the mutable (varying) radius along the stroke.\n(I ignored it in my paper too.)\nThe radii are typically generated from the pressure values as a stylus presses and moves on a tablet.\nFor experienced artists after installing a painting program, one of the highest priorities is to configure the mapping function from pen pressure to brush radius."),(0,o.kt)("p",null,'In this tutorial, you will learn to render a stroke with mutable radius, and the most popular way to stylize it called "Stamp."\nYou cannot find them elsewhere since they come from our own research.\nAdditionally, GPU brush stroke rendering a newly emerged topic.\nResearchers will develop more novel methods in the future.\nSo I will continuously update this tutorial series to teach them.\nMake sure to star our ',(0,o.kt)("a",{parentName:"p",href:"https://github.com/ShenCiao/BrushStrokeTutorial"},"code repository")," for easy access to the latest updates."),(0,o.kt)("h2",{id:"vector-curves"},"Vector curves"),(0,o.kt)("p",null,"Mutable radius is imperative for the most artists when working on digital painting,\nbut it's not defined in public vector standards like SVG.\nThis limitation is one of the primary reasons why lots of digital artists don't use vector workflow.\n(Another one is filling color.)"),(0,o.kt)("p",null,"To support the mutable radius, we will render a unique type of vector curve:\nAn ordered list of points (polyline) with radius values assigned to each point.\nAs a stylus is pressed and moved on a tablet, the program generate a sequence of points to record the trace of movement.\nAdditionally, the pen pressure is transformed into the radius value assigned to each point."),(0,o.kt)("p",null,"We can approximate any type of curve by increasing the number of points in a polyline, whether freehand-drawn or mathematically defined."),(0,o.kt)("h2",{id:"structure"},"Structure"),(0,o.kt)("p",null,"Although the algorithms are very straightforward, I know how hard it could be to learn and replicate a research work.\nThat's why I created this tutorial, designed with a smooth learning curve and providing seamless coding environments."),(0,o.kt)("p",null,"Start with the Basic part, which covers the basics of the rendering methods.\nPlease read the articles in the Basic part in order, or you may miss something important.\nNext, select your favorite topics to learn.\nI will list the extra prerequisites at the very beginning of the articles."),(0,o.kt)("p",null,"Wish you happy learning!"),(0,o.kt)("h2",{id:"cite"},"Cite"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"@inproceedings{Ciallo2023,\n    author = {Ciao, Shen and Wei, Li-Yi},\n    title = {Ciallo: The next-Generation Vector Paint Program},\n    year = {2023},\n    isbn = {9798400701436},\n    publisher = {Association for Computing Machinery},\n    address = {New York, NY, USA},\n    url = {https://doi.org/10.1145/3587421.3595418},\n    doi = {10.1145/3587421.3595418},\n    booktitle = {ACM SIGGRAPH 2023 Talks},\n    articleno = {67},\n    numpages = {2},\n    keywords = {Digital painting, stylized stroke, arrangement, vector graphics. coloring, graphics processing unit (GPU)},\n    location = {Los Angeles, CA, USA},\n    series = {SIGGRAPH '23}\n}\n")),(0,o.kt)("admonition",{title:"Research Tip",type:"note"},(0,o.kt)("p",{parentName:"admonition"},"To demonstrate your research work, select vector drawings have mutable radius or pen pressure data.\nRegular vector drawing datasets don't contain them."),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"Zeyu Wang's work: ",(0,o.kt)("a",{parentName:"li",href:"https://dl.acm.org/doi/10.1145/3450626.3459819"},"Paper")," | ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/zachzeyuwang/tracing-vs-freehand"},"Dataset")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://cloud.blender.org/p/gallery/5b642e25bf419c1042056fc6"},"Blender Grease Pencil")),(0,o.kt)("li",{parentName:"ul"},"Tell me more..."))),(0,o.kt)(v,{mdxType:"ArticulatedLine2D"}))}P.isMDXComponent=!0},8138:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/sketchpad-be46fe81f29f99371fdce79d1452ae85.gif"}}]);