(self.webpackChunkbrush_stroke_tutorial=self.webpackChunkbrush_stroke_tutorial||[]).push([[0],{1410:(e,n,t)=>{const a=t(7694),o=t(3618),r={title:"Brush Stroke Tutorial",tagline:"Learn brush stroke rendering.",url:"https://shenciao.github.io",baseUrl:"/brush-stroke-tutorial/",organizationName:"ShenCiao",projectName:"brush-stroke-tutorial",onBrokenLinks:"throw",onBrokenMarkdownLinks:"warn",i18n:{defaultLocale:"en",locales:["en"]},presets:[["classic",{docs:{routeBasePath:"/",sidebarPath:6679,editUrl:"https://github.com/ShenCiao/brush-stroke-tutorial/tree/main"},blog:!1,theme:{customCss:2295}}]],themeConfig:{image:"img/vanilla-stroke.png",navbar:{title:"Brush Stroke Tutorial",logo:{alt:"logo",src:"img/vanilla-stroke.png"},items:[{type:"docSidebar",sidebarId:"tutorialSidebar",position:"right",label:"Tutorial"},{href:"https://github.com/ShenCiao/brush-stroke-tutorial",label:"GitHub",position:"right"}]},footer:{style:"light",copyright:`Copyright \xa9 ${(new Date).getFullYear()} Brush Stroke Tutorial, under CC BY-SA 4.0 License`},prism:{theme:a,darkTheme:o},docs:{sidebar:{hideable:!0}}},plugins:["raw-loaders"],trailingSlash:!0};e.exports=r},6679:e=>{e.exports={tutorialSidebar:[{type:"autogenerated",dirName:"."}]}},6777:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>I,contentTitle:()=>S,default:()=>V,frontMatter:()=>L,metadata:()=>A,toc:()=>C});var a=t(7462),o=t(7294),r=t(3905),i=t(9477),l=t(5452),s=t(4866),c=t(5162),u=t(3764);const d={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"[",close:"]"},{open:"{",close:"}"},{open:"(",close:")"},{open:"'",close:"'",notIn:["string","comment"]},{open:'"',close:'"',notIn:["string"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},f={tokenPostfix:".glsl",defaultToken:"invalid",keywords:["const","uniform","break","continue","do","for","while","if","else","switch","case","in","out","inout","true","false","invariant","discard","return","sampler2D","samplerCube","sampler3D","struct","radians","degrees","sin","cos","tan","asin","acos","atan","pow","sinh","cosh","tanh","asinh","acosh","atanh","exp","log","exp2","log2","sqrt","inversesqrt","abs","sign","floor","ceil","round","roundEven","trunc","fract","mod","modf","min","max","clamp","mix","step","smoothstep","length","distance","dot","cross ","determinant","inverse","normalize","faceforward","reflect","refract","matrixCompMult","outerProduct","transpose","lessThan ","lessThanEqual","greaterThan","greaterThanEqual","equal","notEqual","any","all","not","packUnorm2x16","unpackUnorm2x16","packSnorm2x16","unpackSnorm2x16","packHalf2x16","unpackHalf2x16","dFdx","dFdy","fwidth","textureSize","texture","textureProj","textureLod","textureGrad","texelFetch","texelFetchOffset","textureProjLod","textureLodOffset","textureGradOffset","textureProjLodOffset","textureProjGrad","intBitsToFloat","uintBitsToFloat","floatBitsToInt","floatBitsToUint","isnan","isinf","vec2","vec3","vec4","ivec2","ivec3","ivec4","uvec2","uvec3","uvec4","bvec2","bvec3","bvec4","mat2","mat3","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","mat4","float","int","uint","void","bool"],operators:["=",">","<","!","~","?",":","==","<=",">=","!=","&&","||","++","--","+","-","*","/","&","|","^","%","<<",">>",">>>","+=","-=","*=","/=","&=","|=","^=","%=","<<=",">>=",">>>="],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,integersuffix:/([uU](ll|LL|l|L)|(ll|LL|l|L)?[uU]?)/,floatsuffix:/[fFlL]?/,encoding:/u|u8|U|L/,tokenizer:{root:[[/[a-zA-Z_]\w*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}],[/^\s*#\s*\w+/,"keyword.directive"],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":""}}],[/\d*\d+[eE]([\-+]?\d+)?(@floatsuffix)/,"number.float"],[/\d*\.\d+([eE][\-+]?\d+)?(@floatsuffix)/,"number.float"],[/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/,"number.hex"],[/0[0-7']*[0-7](@integersuffix)/,"number.octal"],[/0[bB][0-1']*[0-1](@integersuffix)/,"number.binary"],[/\d[\d']*\d(@integersuffix)/,"number"],[/\d(@integersuffix)/,"number"],[/[;,.]/,"delimiter"]],comment:[[/[^\/*]+/,"comment"],[/\/\*/,"comment","@push"],["\\*/","comment","@pop"],[/[\/*]/,"comment"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,{token:"string.quote",bracket:"@close",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,"white"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]]}};function p(e){return o.createElement(u.ML,(0,a.Z)({},e,{defaultLanguage:"glsl",onMount:(n,t)=>{t.languages.register({id:"glsl"}),t.languages.setMonarchTokensProvider("glsl",f),t.languages.setLanguageConfiguration("glsl",d),"function"==typeof e.onMount&&e.onMount(n,t)}}))}const m="const n = 32;\nconst maxRadius = 1/3;\n\nconst position = [];\nconst radius = [];\n\nconst gr = (1 + Math.sqrt(5)) / 2; // golden ratio\nconst pi = Math.PI;\n\nfor(let i = 0; i <= n; ++i){\n  let a = i / n;\n  let x =  -pi + (2 * pi * a);\n  let y = Math.sin(x) / gr;\n  let r = Math.cos(x / 2.0) * maxRadius;\n\n  position.push(x, y);\n  radius.push(r);\n}\n\nreturn [position, radius];\n",h="precision highp float;\nprecision highp int;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec2 position0;\nin float radius0;\nin float summedLength0;\nin vec2 position1;\nin float radius1;\nin float summedLength1;\n\nout vec2 p; // position of the current pixel\nflat out vec2 p0;\nflat out float r0;\nflat out float l0;\nflat out vec2 p1;\nflat out float r1;\nflat out float l1;\n\nvoid main()\t{\n    r0 = radius0;\n    r1 = radius1;\n    p0 = position0;\n    p1 = position1;\n    l0 = summedLength0;\n    l1 = summedLength1;\n\n    vec2 tangentDirection = normalize(position1 - position0);\n    vec2 normalDirection = vec2(-tangentDirection.y, tangentDirection.x);\n    float cosTheta = (r0 - r1)/distance(p0, p1); // theta is the angle stroke tilt, there is a diagram in README to explain this.\n    // the vertex1 with radius is fully inside the vertex0.\n    if(abs(cosTheta) >= 1.0) return;\n\n    // Each instance is a trapzoid, whose vertices' positions are determined here.\n    // Use gl_VertexID {0, 1, 2, 3} to index and get the desired parameters.\n    // Be careful with the backface culling! We are ignoring it here.\n    vec2 offsetSign = vec2[](\n        vec2(-1.0,-1.0),\n        vec2(-1.0, 1.0),\n        vec2( 1.0, 1.0),\n        vec2( 1.0,-1.0)\n    )[gl_VertexID];\n    vec2 position = vec2[](position0, position0, position1, position1)[gl_VertexID];\n    float radius = vec4(radius0, radius0, radius1, radius1)[gl_VertexID];\n\n    float tanHalfTheta = sqrt((1.0+cosTheta) / (1.0-cosTheta));\n    float cotHalfTheta = 1.0 / tanHalfTheta;\n    float normalTanValue = vec4(tanHalfTheta, tanHalfTheta, cotHalfTheta, cotHalfTheta)[gl_VertexID];\n    if(normalTanValue > 10.0 || normalTanValue < 0.1) return;\n\n    vec2 trapzoidVertexPosition = position +\n        offsetSign.x * radius * tangentDirection +\n        offsetSign.y * radius * normalDirection * normalTanValue;\n    p = trapzoidVertexPosition;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(trapzoidVertexPosition, 0.0, 1.0);\n}\n",g="precision highp float;\nprecision highp int;\n\nin vec2 p;\nflat in vec2 p0;\nflat in float r0;\nflat in float l0;\nflat in vec2 p1;\nflat in float r1;\nflat in float l1;\n\n// Common\nuniform int type;\nconst int Vanilla = 0, Stamp = 1, Airbrush = 2;\nuniform vec4 color;\n// Stamp\nuniform highp sampler2D footprint;\nuniform float stampIntervalRatio;\nuniform float noiseFactor;\nuniform float rotationFactor;\nfloat x2n(float x); // from distance to stamp index.\nfloat n2x(float n); // from stamp index to distance.\nmat2 rotate(float angle);\n// Airbrush\nuniform highp sampler2D gradient;\nfloat sampleGraident(float distance){ return texture(gradient, vec2(distance, 0.0)).r; }\n\n// Noise helper functions from _The Book of Shader_.\nfloat random (in vec2 st);\nfloat noise (in vec2 st);\nfloat fbm (in vec2 st);\n\nout vec4 outColor;\n\nvoid main() {\n    vec2 tangent = normalize(p1 - p0);\n    vec2 normal = vec2(-tangent.y, tangent.x);\n\n    // The local coordinate orgin at p0, x axis along the tangent direct.\n    float len = distance(p1, p0);\n    vec2 pLocal = vec2(dot(p-p0, tangent), dot(p-p0, normal));\n    vec2 p0Local = vec2(0, 0);\n    vec2 p1Local = vec2(len, 0);\n\n    float cosTheta = (r0 - r1)/len;\n    float d0 = distance(p, p0);\n    float d0cos = pLocal.x / d0;\n    float d1 = distance(p, p1);\n    float d1cos = (pLocal.x - len) / d1;\n\n    // Remove corners\n    if(d0cos < cosTheta && d0 > r0) discard;\n    if(d1cos > cosTheta && d1 > r1) discard;\n\n    if(type == Vanilla){\n        if(d0 < r0 && d1 < r1) discard;\n        float A = (d0 < r0 || d1 < r1) ? 1.0 - sqrt(1.0 - color.a) : color.a;\n        outColor = vec4(color.rgb, A);\n        return;\n    }\n\n    if(type == Stamp){\n        // The method here is not published yet, it should be explained in a 10min video.\n        // The footprint is a disk instead of a square.\n        // We set a quadratic polynomial to calculate the effect range, the range on polyline edge footprint can touch the current pixel.\n        // Two roots of the quadratic polynomial are the effectRangeFront and effectRangeBack.\n        // Formulas from SIGGRAPH 2022 Talk - A Fast & Robust Solution for Cubic & Higher-Order Polynomials\n        float a, b, c, delta;\n        a = 1.0 - pow(cosTheta, 2.0);\n        b = 2.0 * (r0 * cosTheta - pLocal.x);\n        c = pow(pLocal.x, 2.0) + pow(pLocal.y, 2.0) - pow(r0, 2.0);\n        delta = pow(b, 2.0) - 4.0*a*c;\n        if(delta <= 0.0) discard; // This should never happen.\n\n        float tempMathBlock = b + sign(b) * sqrt(delta);\n        float x1 = -2.0 * c / tempMathBlock;\n        float x2 = -tempMathBlock / (2.0*a);\n        float effectRangeFront = x1 <= x2 ? x1 : x2;\n        float effectRangeBack = x1 > x2 ? x1 : x2;\n\n        // We stamp on polyline every time the stamp index comes to an integer.\n        float index0 = l0/stampIntervalRatio; // The stamp index of vertex0.\n        float startIndex, endIndex;\n        if (effectRangeFront <= 0.0){\n            startIndex = ceil(index0);\n        }\n        else{\n            startIndex = ceil(index0 + x2n(effectRangeFront));\n        }\n        float index1 = l1/stampIntervalRatio;\n        float backIndex = x2n(effectRangeBack) + index0;\n        endIndex = index1 < backIndex ? index1 : backIndex;\n        if(startIndex > endIndex) discard;\n\n        // The main loop to sample and blend color from the footprint.\n        int MAX_i = 128; float currIndex = startIndex;\n        float A = 0.0;\n        for(int i = 0; i < MAX_i; i++){\n            float currStampLocalX = n2x(currIndex - index0);\n            // Apply roation and sample the footprint.\n            vec2 pToCurrStamp = pLocal - vec2(currStampLocalX, 0.0);\n            float currStampRadius = r0 - cosTheta * currStampLocalX;\n            float angle = rotationFactor*radians(360.0*fract(sin(currIndex)*1.0));\n            pToCurrStamp *= rotate(angle);\n            vec2 textureCoordinate = (pToCurrStamp/currStampRadius + 1.0)/2.0;\n            float opacity = texture(footprint, textureCoordinate).a;\n            // Blend opacity.\n            float opacityNoise = noiseFactor*fbm(textureCoordinate*50.0);\n            opacity = clamp(opacity - opacityNoise, 0.0, 1.0) * color.a;\n            A = A * (1.0-opacity) + opacity;\n\n            currIndex += 1.0;\n            if(currIndex > endIndex) break;\n        }\n        if(A < 1e-4) discard;\n        outColor = vec4(color.rgb, A);\n        return;\n    }\n\n    if(type == Airbrush){\n        // The method here is not published yet. Shen is not fully satisfied with the current solution.\n        float tanTheta = sqrt(1.0 - cosTheta*cosTheta)/cosTheta;\n        float mid = pLocal.x - abs(pLocal.y)/tanTheta;\n        float A = color.a;\n        float transparency0 = d0 > r0 ? 1.0:sqrt(1.0 - A*sampleGraident(d0/r0));\n        float transparency1 = d1 > r1 ? 1.0:sqrt(1.0 - A*sampleGraident(d1/r1));\n        float transparency;\n\n        // A bunch of math derived with the continuous form of airbrush here.\n        if(mid <= 0.0){\n            transparency = transparency0/transparency1;\n        }\n        if(mid > 0.0 && mid < len){\n            float r = (mid * r1 + (len - mid) * r0)/len;\n            float dr = distance(pLocal, vec2(mid, 0))/r;\n            transparency = (1.0 - A*sampleGraident(dr))/transparency0/transparency1;\n        }\n        if(mid >= len){\n            transparency = transparency1/transparency0;\n        }\n\n        outColor = vec4(color.rgb, 1.0 - transparency);\n    }\n}\n\nfloat x2n(float x){\n    float L = distance(p0, p1);\n    if(r0 == r1) return x/(stampIntervalRatio*r0);\n    else return -L / stampIntervalRatio / (r0 - r1) * log(1.0 - (1.0 - r1/r0)/L * x);\n}\n\nfloat n2x(float n){\n    float L = distance(p0, p1);\n    if(r0 == r1) return n * stampIntervalRatio * r0;\n    else return L * (1.0-exp(-(r0-r1)*n*stampIntervalRatio/L)) / (1.0-r1/r0);\n}\n\n// Helper functions----------------------------------------------------------------------------------\nmat2 rotate(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n    vec2(12.9898,78.233)))*\n    43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n    (c - a)* u.y * (1.0 - u.x) +\n    (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n";var x=t(1410),v=t.n(x),b=t(412);let y=function(e){return e[e.Vanilla=0]="Vanilla",e[e.Stamp=1]="Stamp",e[e.Airbrush=2]="Airbrush",e}({});function w(e){let{uniforms:n=null}=e;const t=(0,o.useRef)(),a=(0,o.useRef)(),r=(0,o.useRef)();function d(e,n,t){const a=[...n],o=[...n.slice(2)],r=[...t],l=[...t.slice(1)],s=[];let c=0;for(let f=0;f<t.length-1;++f){const e=2*f,a=new i.FM8(n[e],n[e+1]),o=new i.FM8(n[e+2],n[e+3]);let u=t[f],d=t[f+1];const p=1e-5;(u<=0||u/d<p)&&(u=p*d,r[f]=u),(d<=0||d/u<p)&&(d=p*u,l[f]=d);let m=a.distanceTo(o);c+=u<=0&&d<=0?0:u==d?m/u:Math.log(u/d)/(u-d)*m,s.push(c)}const u=[0,...s],d=[...s];e.setAttribute("position0",new i.lb7(new Float32Array(a),2)),e.setAttribute("radius0",new i.lb7(new Float32Array(r),1)),e.setAttribute("position1",new i.lb7(new Float32Array(o),2)),e.setAttribute("radius1",new i.lb7(new Float32Array(l),1)),e.setAttribute("summedLength0",new i.lb7(new Float32Array(u),1)),e.setAttribute("summedLength1",new i.lb7(new Float32Array(d),1))}function f(e,n){const t=r.current.material;e&&(t.vertexShader=e),n&&(t.fragmentShader=n),t.needsUpdate=!0,a.current()}(0,o.useEffect)((()=>{const e=(1+Math.sqrt(5))/2,o=t.current.clientWidth,s=o*(.5/e),c=4*e,u=c*(.5/e),f=new i.iKG(c/-2,c/2,u/2,u/-2,-1e3,1e3);f.position.z=5;const p=new i.CP7({antialias:!0,alpha:!0,premultipliedAlpha:!1,powerPreference:"high-performance"});function x(){const n=t.current.clientWidth,a=.5*n/e;p.setSize(n,a)}p.setClearColor(new i.Ilk(1,1,1),0),p.setSize(o,s),window.addEventListener("resize",x),t.current.appendChild(p.domElement);const v=new i.xsS,b=new l.o(f,p.domElement);b.enableRotate=!1,b.enableDamping=!1,b.screenSpacePanning=!0,b.addEventListener("change",(()=>{p.render(v,f)})),a.current=()=>p.render(v,f),window.addEventListener("TextureLoaded",a.current);const w=new i.u9r;w.setIndex([0,1,2,2,3,0]);const k=new Function(m),[T,L]=k();d(w,T,L);const S={type:{value:y.Vanilla},color:{value:[0,0,0,1]},footprint:{value:new i.xEZ},stampIntervalRatio:{value:1},noiseFactor:{value:0},rotationFactor:{value:0},gradient:{value:new i.IEO}},A=new i.FIo({uniforms:n||S,vertexShader:h,fragmentShader:g,side:i.ehD,transparent:!0,glslVersion:i.LSk});return r.current=new i.SPe(w,A,T.length-1),r.current.frustumCulled=!1,v.add(r.current),a.current(),console.log("yes"),()=>{p.dispose(),window.removeEventListener("resize",x),window.removeEventListener("TextureLoaded",a.current),console.log("unmounted")}}),[]);const x=(0,o.useCallback)(((e,n)=>{let t=[],o=[];try{const n=new Function(e);[t,o]=n()}catch(l){return void console.log(l.toString())}function i(e){if(Array.isArray(e)){for(let n=0;n<e.length;n++)if("number"!=typeof e[n])return!1;return!0}return!1}i(t)&&i(o)&&t.length==2*o.length?(d(r.current.geometry,t,o),r.current.count=t.length-1,a.current()):console.log("return value is not correct")}),[]),v="60vh";return o.createElement(o.Fragment,null,o.createElement(s.Z,null,o.createElement(c.Z,{value:"geometry.js"},o.createElement(u.ZP,{height:v,defaultLanguage:"javascript",defaultValue:m,onChange:x})),o.createElement(c.Z,{value:"vertex.glsl"},o.createElement(p,{height:v,defaultValue:h,onChange:e=>{f(e,"")}})),o.createElement(c.Z,{value:"fragment.glsl"},o.createElement(p,{height:v,defaultValue:g,onChange:e=>{f("",e)}}))),o.createElement("div",{ref:t,style:{width:"100%"},onMouseDown:e=>e.preventDefault()}))}let k=new i.xEZ;b.Z.canUseDOM&&(k=(new i.dpR).load(`/${v().projectName}/img/stamp2.png`,(e=>{window.dispatchEvent(new CustomEvent("TextureLoaded"))}),void 0,void 0));const T={type:{value:y.Stamp},color:{value:[0,0,0,1]},footprint:{value:k},stampIntervalRatio:{value:.4},noiseFactor:{value:1.2},rotationFactor:{value:.75}},L={position:1},S=void 0,A={unversionedId:"Basics/Vanilla",id:"Basics/Vanilla",title:"Vanilla",description:"",source:"@site/docs/Basics/Vanilla.mdx",sourceDirName:"Basics",slug:"/Basics/Vanilla",permalink:"/brush-stroke-tutorial/Basics/Vanilla",draft:!1,editUrl:"https://github.com/ShenCiao/brush-stroke-tutorial/tree/main/docs/Basics/Vanilla.mdx",tags:[],version:"current",frontMatter:{position:1},sidebar:"tutorialSidebar",previous:{title:"Basics",permalink:"/brush-stroke-tutorial/category/basics"},next:{title:"Appendix",permalink:"/brush-stroke-tutorial/category/appendix"}},I={},C=[],F={toc:C},E="wrapper";function V(e){let{components:n,...t}=e;return(0,r.kt)(E,(0,a.Z)({},F,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)(w,{uniforms:T,mdxType:"ArticulatedLine2D"}))}V.isMDXComponent=!0}}]);