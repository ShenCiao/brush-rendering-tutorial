"use strict";(self.webpackChunkbrush_stroke_tutorial=self.webpackChunkbrush_stroke_tutorial||[]).push([[342],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(r),d=a,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||i;return r?n.createElement(m,o(o({ref:t},c),{},{components:r})):n.createElement(m,o({ref:t},c))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=r[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},9106:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=r(7462),a=(r(7294),r(3905));const i={sidebar_position:2},o=void 0,s={unversionedId:"Basics/Stamp/Stamp",id:"Basics/Stamp/Stamp",title:"Stamp",description:"Intro",source:"@site/docs/Basics/Stamp/Stamp.mdx",sourceDirName:"Basics/Stamp",slug:"/Basics/Stamp/",permalink:"/brush-rendering-tutorial/Basics/Stamp/",draft:!1,editUrl:"https://github.com/ShenCiao/brush-rendering-tutorial/tree/main/docs/Basics/Stamp/Stamp.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Vanilla",permalink:"/brush-rendering-tutorial/Basics/Vanilla/"},next:{title:"Tessellation",permalink:"/brush-rendering-tutorial/Tessellation/"}},l={},p=[{value:"Intro",id:"intro",level:2},{value:"Locate stamps",id:"locate-stamps",level:2}],c={toc:p},u="wrapper";function h(e){let{components:t,...i}=e;return(0,a.kt)(u,(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"intro"},"Intro"),(0,a.kt)("p",null,"The basic stamp stroke rendering is pretty intuitive.\nWe are given a texture called stamp texture or footprint.\nWhile a user paints on a canvas, we render the texture onto the canvas equidistantly along the drawing trace.\nWhen the textures are close enough, they seem continuous and form a stroke."),(0,a.kt)("p",null,"todo: figure"),(0,a.kt)("p",null,"Artists love to create stamp brush since it's expressive and intuitive.\nMore than 90% of brushes in popular paint software are stamp brushes.\nResearchers and developers have developed dozens of extra parameters\nthat can apply various aspects of stylization on a stroke.\nHow to replicate these parameters with GPU-acceleration is under researched.\nTherefore, we will focus on the most critical technique, how to place the stamp textures within a shader program."),(0,a.kt)("p",null,"A naive solution is to place the stamp texture at each vertex. The vertices are shown with the dots the figure with  below:\n",(0,a.kt)("img",{alt:"naive",src:r(899).Z,width:"1276",height:"897"}),"\nBut it's not good enough for the most usage.\nThe rendering result of strokes depends on polylines' vertex density.\nAfter subdividing, simplify or deforming the polylines, the strokes get denser or sparser appearance, which ruins the rendering result.\nWe must develop methods that rendering is independent of vertex density, just like rendering 3D meshes.\nTherefore, I will introduce you how to place stamp textures equidistantly along a polyline."),(0,a.kt)("h2",{id:"locate-stamps"},"Locate stamps"),(0,a.kt)("p",null,"When rendering with CPU, calculating where to place stamp (stamp position) on a polyline is pretty straightforward.\nStart from the very first vertex of the polyline, loop to move with a preset stamp interval at each step\nuntil reach the end of polyline."),(0,a.kt)("p",null,"todo: diagram"),(0,a.kt)("p",null,"To render with GPU, we use the same method as rendering vanilla stroke:\nPlacing the four new vertices for each edge and discard corners.\nAnd we will calculate the stamp positions in the fragment shader for each invoked pixel.\nAt each polyline vertex, we compute its distance to the first vertex along the polyline, which is the prefix sum of edge lengths.\nSince we place stamps equidistantly starting from the first vertex,\nthe stamp positions can be calculated in all pixels invoked by each edge.\nThen a pixel can sample the stamp textures and determine its color.\nWe compute the texture coordinate with the pixel's distance to the stamp positions and radii."),(0,a.kt)("p",null,"todo: diagram"),(0,a.kt)("details",null,(0,a.kt)("summary",null," Parallel prefix sum "),(0,a.kt)("p",null,"There are parallel prefix sum algorithms can be implemented with compute shaders.\n",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Prefix_sum#Parallel_algorithms"},"Wiki"),".\nBy implementing one of them, the whole rendering process is GPU-accelerated."),(0,a.kt)("p",null,"The best tutorial about prefix sum I've ever found is this free course ",(0,a.kt)("a",{parentName:"p",href:"https://www.udacity.com/course/high-performance-computing--ud281"},"High Performance Computing"),"\nby Prof. Rich Vuduc.\nThe course introduces prefix sum in Lesson 6.")),(0,a.kt)("p",null,"But an edge can be very long and has many unnecessary stamps for a pixel to loop through.\nWe constrain the calculation within only a segment of the edge, within which stamps can cover the current pixel.\nGiven the pixel's coordinate, we can calculate the min and max point of the segment.\nAn extra geometry puzzle to solve:"),(0,a.kt)("p",null,"todo: diagram"),(0,a.kt)("p",null,"From the diagram, we can set a quadratic polynomial.\nTwo roots of it are the min and max points of the segment."))}h.isMDXComponent=!0},899:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/dotted-monkey-cf1ca1e77f00864b77d2fead263e3f4c.png"}}]);