"use strict";(self.webpackChunkbrush_stroke_tutorial=self.webpackChunkbrush_stroke_tutorial||[]).push([[805],{5034:(e,a,t)=>{t.d(a,{r:()=>l});var n=t(7462),s=t(7294);const r={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"[",close:"]"},{open:"{",close:"}"},{open:"(",close:")"},{open:"'",close:"'",notIn:["string","comment"]},{open:'"',close:'"',notIn:["string"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},i={tokenPostfix:".glsl",defaultToken:"invalid",keywords:["const","uniform","break","continue","do","for","while","if","else","switch","case","in","out","inout","true","false","invariant","discard","return","sampler2D","samplerCube","sampler3D","struct","radians","degrees","sin","cos","tan","asin","acos","atan","pow","sinh","cosh","tanh","asinh","acosh","atanh","exp","log","exp2","log2","sqrt","inversesqrt","abs","sign","floor","ceil","round","roundEven","trunc","fract","mod","modf","min","max","clamp","mix","step","smoothstep","length","distance","dot","cross ","determinant","inverse","normalize","faceforward","reflect","refract","matrixCompMult","outerProduct","transpose","lessThan ","lessThanEqual","greaterThan","greaterThanEqual","equal","notEqual","any","all","not","packUnorm2x16","unpackUnorm2x16","packSnorm2x16","unpackSnorm2x16","packHalf2x16","unpackHalf2x16","dFdx","dFdy","fwidth","textureSize","texture","textureProj","textureLod","textureGrad","texelFetch","texelFetchOffset","textureProjLod","textureLodOffset","textureGradOffset","textureProjLodOffset","textureProjGrad","intBitsToFloat","uintBitsToFloat","floatBitsToInt","floatBitsToUint","isnan","isinf","vec2","vec3","vec4","ivec2","ivec3","ivec4","uvec2","uvec3","uvec4","bvec2","bvec3","bvec4","mat2","mat3","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","mat4","float","int","uint","void","bool"],operators:["=",">","<","!","~","?",":","==","<=",">=","!=","&&","||","++","--","+","-","*","/","&","|","^","%","<<",">>",">>>","+=","-=","*=","/=","&=","|=","^=","%=","<<=",">>=",">>>="],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,integersuffix:/([uU](ll|LL|l|L)|(ll|LL|l|L)?[uU]?)/,floatsuffix:/[fFlL]?/,encoding:/u|u8|U|L/,tokenizer:{root:[[/[a-zA-Z_]\w*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}],[/^\s*#\s*\w+/,"keyword.directive"],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":""}}],[/\d*\d+[eE]([\-+]?\d+)?(@floatsuffix)/,"number.float"],[/\d*\.\d+([eE][\-+]?\d+)?(@floatsuffix)/,"number.float"],[/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/,"number.hex"],[/0[0-7']*[0-7](@integersuffix)/,"number.octal"],[/0[bB][0-1']*[0-1](@integersuffix)/,"number.binary"],[/\d[\d']*\d(@integersuffix)/,"number"],[/\d(@integersuffix)/,"number"],[/[;,.]/,"delimiter"]],comment:[[/[^\/*]+/,"comment"],[/\/\*/,"comment","@push"],["\\*/","comment","@pop"],[/[\/*]/,"comment"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,{token:"string.quote",bracket:"@close",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,"white"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]]}};var m=t(3764);function l(e){return s.createElement(m.ML,(0,n.Z)({},e,{defaultLanguage:"glsl",onMount:(a,t)=>{t.languages.register({id:"glsl"}),t.languages.setMonarchTokensProvider("glsl",i),t.languages.setLanguageConfiguration("glsl",r),"function"==typeof e.onMount&&e.onMount(a,t)}}))}},9279:(e,a,t)=>{t.d(a,{Z:()=>n});const n="// Generate sinewave geometry \nconst maxRadius = 1/3;\nconst segmentCount = 32;\n\nconst position = [];\nconst radius = [];\n\nconst gr = (1 + Math.sqrt(5)) / 2; // golden ratio\nconst pi = Math.PI;\n\nfor(let i = 0; i <= segmentCount; ++i){\n  let a = i / segmentCount\n  let x =  -pi + (2 * pi * a);\n  let y = Math.sin(x) / gr;\n  let r = Math.cos(x / 2.0) * maxRadius;\n\n  position.push(x, y);\n  radius.push(r);\n}\n\nreturn [position, radius];\n"},8089:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>w,contentTitle:()=>f,default:()=>L,frontMatter:()=>k,metadata:()=>v,toc:()=>x});var n=t(7462),s=t(7294),r=t(3905),i=t(9477),m=t(5452),l=t(4866),p=t(5162),o=t(3764),c=t(5034);function u(e){let{geometry:a,vertexShader:t,fragmentShader:n,showEditor:r=null}=e;const u=(0,s.useRef)(),h=(0,s.useRef)(),d=(0,s.useRef)(),g=(0,s.useRef)();function N(e,a,t){const n=[...a],s=[...a.slice(2)],r=[...t],m=[...t.slice(1)],l=[];let p=0;for(let u=0;u<t.length-1;++u){const e=2*u,n=new i.FM8(a[e],a[e+1]),s=new i.FM8(a[e+2],a[e+3]);let o=t[u],c=t[u+1];const h=1e-5;(o<=0||o/c<h)&&(o=h*c,r[u]=o),(c<=0||c/o<h)&&(c=h*o,m[u]=c);let d=n.distanceTo(s);p+=o<=0&&c<=0?0:o==c?d/o:Math.log(o/c)/(o-c)*d,l.push(p)}const o=[0,...l],c=[...l];e.setAttribute("position0",new i.lb7(new Float32Array(n),2)),e.setAttribute("radius0",new i.lb7(new Float32Array(r),1)),e.setAttribute("position1",new i.lb7(new Float32Array(s),2)),e.setAttribute("radius1",new i.lb7(new Float32Array(m),1)),e.setAttribute("summedLength0",new i.lb7(new Float32Array(o),1)),e.setAttribute("summedLength1",new i.lb7(new Float32Array(c),1))}function k(e,a){const t=d.current.material;e&&(t.vertexShader=e),a&&(t.fragmentShader=a),t.needsUpdate=!0,h.current()}(0,s.useEffect)((()=>{const e=(1+Math.sqrt(5))/2,s=u.current.clientWidth,r=s*(.5/e),l=6*e,p=l*(.5/e),o=new i.iKG(l/-2,l/2,p/2,p/-2,-1e3,1e3);o.position.z=5;const c=new i.CP7({preserveDrawingBuffer:!0,powerPreference:"high-performance",antialias:!0,alpha:!0,premultipliedAlpha:!1});function k(){const a=u.current.clientWidth,t=.5*a/e;c.setSize(a,t)}c.setClearColor(new i.Ilk(1,1,1),0),c.setSize(s,r),g.current=c,window.addEventListener("resize",k),u.current.appendChild(c.domElement);const f=new i.xsS,v=new m.o(o,c.domElement);v.enableRotate=!1,v.enableDamping=!1,v.screenSpacePanning=!0,v.addEventListener("change",(()=>{c.render(f,o)})),h.current=()=>c.render(f,o),window.addEventListener("TextureLoaded",h.current);let w=new i.u9r;if("string"==typeof a){const e=[0,1,2,2,3,0];w.setIndex(e);const t=new Function(a),[n,s]=t();N(w,n,s)}else{if(!(a instanceof i.u9r))return void console.error("Unrecognized geometry input: "+typeof a);w=a}const x=new i.FIo({vertexShader:t,fragmentShader:n,side:i.ehD,transparent:!0,glslVersion:i.LSk});return d.current=new i.SPe(w,x,w.getAttribute("position0").count-1),d.current.frustumCulled=!1,f.add(d.current),h.current(),()=>{c.dispose(),window.removeEventListener("resize",k),window.removeEventListener("TextureLoaded",h.current)}}),[]);const f=(0,s.useCallback)(((e,a)=>{let t=[],n=[];try{const a=new Function(e);[t,n]=a()}catch(r){return void console.log(r.toString())}function s(e){if(Array.isArray(e)){for(let a=0;a<e.length;a++)if("number"!=typeof e[a])return!1;return!0}return!1}s(t)&&s(n)&&t.length==2*n.length?(N(d.current.geometry,t,n),d.current.count=t.length-1,h.current()):console.error("return value is not correct")}),[]),v="60vh";let w=!0,x=!0,b=!0;return Array.isArray(r)&&([w,x,b]=r,r=w||x||b),a instanceof i.u9r&&(w=!1),s.createElement(s.Fragment,null,r&&s.createElement("div",null,s.createElement(l.Z,{defaultValue:""},w&&s.createElement(p.Z,{value:"geometry.js"},s.createElement(o.ZP,{height:v,defaultLanguage:"javascript",defaultValue:a,onChange:f})),x&&s.createElement(p.Z,{value:"vertex.glsl"},s.createElement(c.r,{height:v,defaultValue:t,onChange:e=>{k(e,"")}})),b&&s.createElement(p.Z,{value:"fragment.glsl"},s.createElement(c.r,{height:v,defaultValue:n,onChange:e=>{k("",e)}})))),s.createElement("div",{ref:u,style:{width:"100%"},onMouseDown:e=>{e.preventDefault(),2==e.button&&console.log(g.current.domElement.toDataURL())}}))}var h=t(9279);const d="precision mediump float;\nprecision mediump int;\n\n// Take golbal const values like the `radius` here as uniforms. You can modify them freely.\nconst float radius = 1.0/5.0;\n\nuniform mat4 modelViewMatrix;\n// The `projectionMatrix` is a orthogonal projection matrix here, which is the default setting when rendering 2D stuff.\nuniform mat4 projectionMatrix;\n\n// The position of polyline vertices v_i and v_{i+1}\nin vec2 position0;\nin vec2 position1;\n\n// Output values to the fragment shader, `p` will be the current world position of a pixel. The others are shown in the diagram.\n// If you don't know about the `flat` qualifier here, you should jump right into the description below and come back later.\nout vec2 p;\nflat out vec2 p0;\nflat out vec2 p1;\nflat out float r;\n\nvoid main(){\n    p0 = position0;\n    p1 = position1;\n    r = radius;\n\n    vec2 tangent = normalize(p1 - p0);\n    vec2 normal = vec2(-tangent.y, tangent.x);\n\n    /* Each instance is a rectangle, whose vertices' positions are determined here.\n    * The built-in variable `gl_VertexID` records the vertex index, whose value is one of the {0, 1, 2, 3}\n    * We use `gl_VertexID` to index values we need for.\n    * Here, 0 is the vertex on the lowerleft corner, 1 upperleft, 2 upperright, 3 lowerright\n    */\n    vec2 position = vec2[](p0, p0, p1, p1)[gl_VertexID];\n    vec2 offsetSign = vec2[](\n        vec2(-1.0, -1.0),\n        vec2(-1.0, 1.0),\n        vec2(1.0, 1.0),\n        vec2(1.0, -1.0)\n    )[gl_VertexID];\n\n    vec2 vertexPosition = position +\n        offsetSign.x * r * tangent +\n        offsetSign.y * r * normal;\n\n    // Output positions are interpolated by the graphics pipeline to give us the world poisition of a pixel in fragement shader.\n    p = vertexPosition;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 0.0, 1.0);\n}",g="precision mediump float;\nprecision mediump int;\n\nconst vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\nout vec4 outColor;\n\nin vec2 p;\n// These variable are shown in the diagram\nflat in vec2 p0;\nflat in vec2 p1;\nflat in float r;\n\nvoid main() {\n    vec2 tangent = normalize(p1 - p0);\n    vec2 normal = vec2(-tangent.y, tangent.x);\n    float len = distance(p1, p0);\n\n    // Calculate the pixel position in the local coordinate shown in the diagram.\n    vec2 pLocal = vec2(dot(p-p0, tangent), dot(p-p0, normal));\n\n    float d0 = distance(p, p0);\n    float d1 = distance(p, p1);\n\n    // Remove corners\n    if(pLocal.x < 0.0 && d0 > r) discard; // left corners\n    if(pLocal.x > len && d1 > r) discard; // right corners\n\n    outColor = color;\n}";function N(e){let{showEditor:a=[!1,!1,!1]}=e;return s.createElement(u,{geometry:h.Z,vertexShader:d,fragmentShader:g,showEditor:a})}const k={sidebar_position:1},f=void 0,v={unversionedId:"Basics/Vanilla/Vanilla",id:"Basics/Vanilla/Vanilla",title:"Vanilla",description:"Uni-radius",source:"@site/docs/Basics/Vanilla/Vanilla.mdx",sourceDirName:"Basics/Vanilla",slug:"/Basics/Vanilla/",permalink:"/brush-rendering-tutorial/Basics/Vanilla/",draft:!1,editUrl:"https://github.com/ShenCiao/brush-rendering-tutorial/tree/main/docs/Basics/Vanilla/Vanilla.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Basics",permalink:"/brush-rendering-tutorial/Basics/Basics/"},next:{title:"Tessellation",permalink:"/brush-rendering-tutorial/Tessellation/"}},w={},x=[{value:"Uni-radius",id:"uni-radius",level:2}],b={toc:x},y="wrapper";function L(e){let{components:a,...s}=e;return(0,r.kt)(y,(0,n.Z)({},b,s,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"uni-radius"},"Uni-radius"),(0,r.kt)("p",null,"Let's start with a solid stroke with a single radius value.\nLater add variable radius to it."),(0,r.kt)("p",null,"We are given a polyline with a set of vertices.\nIn the diagram below, we select an edge with two consecutive vertices, labeled as ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"v"),(0,r.kt)("mi",{parentName:"msub"},"i"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"v_i")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3117em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.0359em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"i")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"}))))))))))," and ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"v"),(0,r.kt)("mrow",{parentName:"msub"},(0,r.kt)("mi",{parentName:"mrow"},"i"),(0,r.kt)("mo",{parentName:"mrow"},"+"),(0,r.kt)("mn",{parentName:"mrow"},"1")))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"v_{i+1}")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6389em",verticalAlign:"-0.2083em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3117em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"-0.0359em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"i"),(0,r.kt)("span",{parentName:"span",className:"mbin mtight"},"+"),(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1"))))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.2083em"}},(0,r.kt)("span",{parentName:"span"})))))))))),".\nWe render a capsule on it, as shown on the left.\nIf we render every single edge like this, edges will connect to each other naturally, as shown on the right."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},(0,r.kt)("img",{alt:"edge",src:t(2003).Z,width:"2560",height:"1080"})),(0,r.kt)("th",{parentName:"tr",align:"center"},(0,r.kt)("img",{alt:"edge",src:t(9948).Z,width:"2560",height:"1080"})))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("em",{parentName:"td"},"An edge")),(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("em",{parentName:"td"},"Connected edges"))))),(0,r.kt)("p",null,"The diagram quite looks like drawing an ",(0,r.kt)("a",{parentName:"p",href:"https://www.google.com/search?q=articulated+arm+2D+diagram&tbm=isch"},"articulated arm"),".\nTherefore, we call it ",(0,r.kt)("strong",{parentName:"p"},"articulated")," stroke (Line) rendering."),(0,r.kt)("p",null,"The idea is pretty straightforward, also easy to implement with GPU APIs.\nTo draw the capsule, we generate four new vertices to make a rectangle, as shown in the left figure below.\nThen discard the pixels in the four corners in fragment shader, as shown in the right figure. All is done!"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},(0,r.kt)("img",{alt:"quad",src:t(2621).Z,width:"2560",height:"1080"})),(0,r.kt)("th",{parentName:"tr",align:"center"},(0,r.kt)("img",{alt:"quad",src:t(561).Z,width:"2560",height:"1080"})))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("em",{parentName:"td"},"Generate rectangle vertices ")),(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("em",{parentName:"td"},"Discard corners"))))),(0,r.kt)("p",null,"There are several possible ways to generate the rectangle vertices.\nThe most elegant one is using geometry shader.\nBut sadly, it's not supported on Apple's ecosystem and web platform, many readers are not experienced in it.\nSo I will mainly introduce instanced rendering implementation.\nBut if you're already familiar with geometry shader, check out the dropdown tab below."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"geometry shader implementation")),(0,r.kt)("p",null,"We use instanced rendering to draw a large number of objects with the same vertex data.\nFor drawing a stroke, each instance is the rectangle shown above, and the number of instances is the number of stroke's edges\n(number of polyline vertices minus one).\nTo place a rectangle, each vertex invoked by the rectangle needs to know about the positions of polyline vertices ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"p"),(0,r.kt)("mn",{parentName:"msub"},"0"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p_0")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"0")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"}))))))))))," and ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"p"),(0,r.kt)("mn",{parentName:"msub"},"1"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p_1")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))))))),", and radius value ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"r")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"r")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"r"))))),".\nWe will set a local coordinate in the shader program, origin at ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"p"),(0,r.kt)("mn",{parentName:"msub"},"0"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"p_0")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"p"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"0")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))))))),", X and Y axes align to the tangent and normal direction:\n",(0,r.kt)("img",{alt:"coo",src:t(9367).Z,width:"2560",height:"1080"})),(0,r.kt)("p",null,'You will find implementation details in the comments of the shader code below.\nThe "vertex.glsl" for the vertex shader and "fragment.glsl" for the fragment shader, feel free to change them:'),(0,r.kt)(N,{showEditor:[!1,!0,!0],mdxType:"VanillaStroke"}),(0,r.kt)("details",null,(0,r.kt)("summary",null,"In case you don't know the `flat` qualifier"),(0,r.kt)("p",null,"Shader variables are interpolated by default in fragment shader.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"flat")," qualifier tells your shader program don't interpolate the variable in fragment shader.\nIf you are still confusing, check out the this ",(0,r.kt)("a",{parentName:"p",href:"https://www.geeks3d.com/20130514/opengl-interpolation-qualifiers-glsl-tutorial/"},"article"),".")))}L.isMDXComponent=!0},9367:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/coordinate-68714349e3013c769921a0eb25796188.png"},2003:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/uni-capsule-2431a7ac5ef2ad09ed6f95c0bdc851cc.png"},9948:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/uni-connect-154f70dedb0fdc2925c947b72c9b5e63.png"},561:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/uni-quad-capsule-b5f5c7122375176a3a612ac132814fe5.png"},2621:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/uni-quad-faf9f304af7d8eb2aa3e3f4b48fe0a24.png"}}]);